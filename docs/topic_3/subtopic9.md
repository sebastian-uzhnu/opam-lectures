# Значимі та посилальні типи даних

У платформі .NET всі типи даних поділяються на дві основні категорії: **значимі типи** (value types) і **посилальні типи
** (reference types). Розуміння різниці між ними критично важливе для ефективного використання пам'яті, передачі даних
між методами та оптимізації програм.

Щоб наочно зрозуміти різницю:

* Value Types / Стек: кожна змінна — своя копія, незалежна. Зручно для швидких обчислень і короткоживучих даних.
* Reference Types / Куча: змінні посилаються на один об'єкт. Зручно для складних структур, спільного використання та
  довгоживучих даних.

Це пояснює, чому, наприклад, зміна властивості класу через одну змінну впливає на всі посилання на цей об'єкт, а зміна
числа не впливає на інші змінні.

---

### Значимі типи (Value Types)

**Значимі типи** зберігають свої значення безпосередньо в пам'яті. Кожна змінна значимого типу містить власне значення,
а не посилання на інше місце в пам'яті.

**Основні особливості:**

- Зазвичай зберігаються у **стеку**.
- Кожна змінна містить власне значення.
- При присвоєнні копіюється значення, а не посилання.
- Не можуть бути `null` (за винятком nullable типів).

**Приклади значимих типів:**

- Примітивні: `int`, `float`, `bool`, `char`, `double`, `decimal`
- Структури: `struct`
- Перелічувані типи: `enum`

**Приклад:**

```csharp
int a = 10;
int b = a;  // b містить копію значення a, а не посилання
a = 20;     // Змінна b залишається рівною 10, оскільки вона зберігає власне значення
```

```csharp
void AddTen(int number)
{
    number += 10; // змінюємо тільки локальну копію
}

int myNumber = 5;
AddTen(myNumber);
Console.WriteLine(myNumber); // все ще 5, бо копія змінилася, а не оригінал
```

---

### Посилальні типи (Reference Types)

**Посилальні типи** зберігають **посилання на об'єкт у пам'яті**, зазвичай у **кучі**. Зміна об'єкта через одну змінну
впливає на всі змінні, які посилаються на нього.

**Основні особливості:**

- Зберігаються у **кучі**.
- При присвоєнні копіюється посилання, а не сам об'єкт.
- Можуть бути `null`.

**Приклади посилальних типів:**

- Класи: `class`
- Інтерфейси: `interface`
- Делегати: `delegate`
- Масиви: `array`
- Рядки: `string`

**Приклад:**

```csharp
class Person
{
    public string Name;
}

Person person1 = new Person();
person1.Name = "Alice";
Person person2 = person1;  // person2 і person1 посилаються на один і той самий об'єкт
person2.Name = "Bob";      // Зміна через person2 змінює значення і для person1
```

---

### 3. **Основні відмінності між значимими та посилальними типами**

| **Характеристика**         | **Значимі типи**    | **Посилальні типи**      |
|----------------------------|---------------------|--------------------------|
| **Зберігають значення**    | Безпосередньо       | Посилання на об'єкт      |
| **Розташування в пам'яті** | Стек                | Куча                     |
| **Передача в методи**      | За значенням        | За посиланням            |
| **Можуть бути null**       | Ні (крім nullable)  | Так                      |
| **Копіювання**             | Копіюється значення | Копіюється посилання     |
| **Життєвий цикл**          | Короткочасний       | Довший, контролюється GC |

---

### Nullable значимі типи

Nullable типи дозволяють значимим типам приймати `null` за допомогою `?`.

**Приклад:**

```csharp
int? nullableInt = null;
if (nullableInt.HasValue)
{
    Console.WriteLine(nullableInt.Value);
}
else
{
    Console.WriteLine("Значення відсутнє");
}
```

**Реальний сценарій:**

- Робота з базами даних, опційними значеннями, невідомими даними.

---

### 5. **Boxing та Unboxing**

- **Boxing** — перетворення значимого типу в посилальний (об'єкт).
- **Unboxing** — вилучення значимого типу з об'єкта.

**Приклад:**

```csharp
int value = 123;
object obj = value;  // Boxing: значимий тип перетворюється в об'єкт
int newValue = (int)obj;  // Unboxing: об'єкт перетворюється назад у значимий тип
```

**Реальний сценарій:**

- Використання старих API, що працюють з `object`, або колекцій до появи generics.

---

### 6. **Приклади коду для наочної демонстрації різниці**

#### **Стек і значимі типи:**

```csharp
int x = 10;
int y = x;  // копія значення
y = 20;
// x все ще 10, y = 20
```

### Питання для самоперевірки:

1. У чому полягає основна різниця між значимими та посилальними типами в C#?
2. Як працює механізм boxing та unboxing?
3. Що таке nullable значимі типи і для чого вони використовуються?
4. Які типи даних у C# є значимими, а які — посилальними?
5. Що відбувається при передачі значимих та посилальних типів у методи?
