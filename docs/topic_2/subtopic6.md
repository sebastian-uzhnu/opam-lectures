---
sidebar_position: 6
---

# Garbage Collector

Збирач сміття (Garbage Collector, GC) — це автоматизована система керування пам’яттю, що звільняє невикористовувані
ресурси та об'єкти для уникнення перевантаження системи й збоїв у роботі. Основна мета збирача сміття полягає у
вивільненні пам'яті, зайнятої об'єктами, які більше не використовуються, що дозволяє уникнути витоків пам'яті та
автоматично підтримує стабільну роботу програм.

### Як працює GC?

GC слідкує за об'єктами в купі (heap) пам'яті, де зберігаються об'єкти, створені програмою. Основні етапи роботи GC:

    - **Виявлення недоступних об'єктів**: GC використовує різні алгоритми для визначення, чи об'єкт досяжний або ні. Це може включати алгоритми, такі як підрахунок посилань або алгоритми збирання сміття на основі розподілу поколінь.
    - **Збір сміття**: Коли об'єкти виявляються недоступними, GC їх видаляє і звільняє пам'ять.
    - **Фрагментація пам'яті**: GC також може реорганізувати пам'ять для зменшення фрагментації.

#### Типи збирання сміття:

    - **Збирання сміття на основі поколінь**: GC поділяє об'єкти на покоління (молодше, середнє, старше). Нові об'єкти починають з молодшого покоління. Це дозволяє зменшити накладні витрати на часте збирання сміття для короткоживучих об'єктів.
    - **Компактне збирання сміття**: Це техніка, яка реорганізовує пам'ять, щоб зменшити фрагментацію.

### Пам’ять у C# і її організація

Пам'ять у C# організована таким чином:

- **Стек (Stack)**: для локальних змінних і примітивних типів даних.
- **Купа (Heap)**: для об'єктів, які мають невизначений життєвий цикл і створюються за допомогою оператора `new`. Саме в
  купі працює збирач сміття.

Коли ми створюємо об’єкти за допомогою ключового слова `new`, пам'ять виділяється в купі. Під час виконання програми
деякі з цих об'єктів стають недоступними (тобто більше не використовуються), але пам'ять, зайнята ними, залишається
виділеною. Тут вступає в гру збирач сміття.

### Основні принципи роботи збирача сміття

Збирач сміття використовує кілька ключових концепцій:

- **Управління поколіннями** (Generational Garbage Collection).
- **Алгоритм маркування та очищення** (Mark-and-Sweep).
- **Компактування пам'яті** (Compaction).

### Управління поколіннями

Управління поколіннями базується на тому, що більшість об'єктів живуть недовго. Таким чином, система ділить об'єкти на *
*покоління**:

- **Generation 0 (Покоління 0)**: Сюди потрапляють новостворені об'єкти. Це наймолодше покоління, яке перевіряється
  найчастіше. Очікується, що більшість об'єктів "живуть" коротко і можуть бути швидко очищені на цьому етапі.
- **Generation 1 (Покоління 1)**: Якщо об'єкти з покоління 0 переживають одну збірку сміття, вони переміщаються в
  покоління 1. Це об'єкти з довшим життєвим циклом.
- **Generation 2 (Покоління 2)**: Сюди потрапляють об'єкти, які прожили кілька циклів очищення. Це найстаріші й найбільш
  стійкі об'єкти. Очищення покоління 2 відбувається рідше, оскільки цей процес є більш витратним з точки зору ресурсів.

Чому так? Якщо збирати сміття в Generation 0 — це швидка й ефективна операція, то чим більше покоління, тим більше
об'єктів воно містить, що робить процес повільнішим. Ось чому покоління 0 перевіряється частіше.

### Алгоритм "Маркування та Очищення"

Збирач сміття в C# використовує алгоритм **Mark-and-Sweep**, що складається з двох основних етапів:

1. **Маркування (Mark)**:
    - На цьому етапі GC ідентифікує всі "живі" об'єкти, тобто об'єкти, до яких є посилання. Алгоритм обходить всі
      кореневі об'єкти (root objects), які зберігаються в стеку або глобальних змінних, і слідкує за кожним об'єктом, що
      знаходиться у посиланнях.
    - Якщо об'єкт доступний із кореневого об'єкта або є частиною ланцюжка посилань, він вважається "живим". Всі інші
      об'єкти є кандидатами на очищення.
2. **Очищення (Sweep)**:
    - На цьому етапі збирач сміття звільняє пам'ять, зайняту об'єктами, які не були помічені під час етапу маркування.
    - Пам'ять цих об'єктів стає доступною для виділення нових об'єктів.

### Компактування пам'яті

Після етапу очищення залишаються "дірки" в купі (неперервні вільні ділянки пам'яті). Щоб уникнути фрагментації, GC
виконує **компактування пам'яті**, переміщуючи живі об'єкти у безперервний блок пам'яті. Це дозволяє уникнути проблем з
фрагментацією і забезпечує ефективне використання пам'яті.

### Тригери для збірки сміття

Збирач сміття працює автоматично, але є кілька випадків, коли він може бути викликаний:

1. **Досягнення певного порогу використання пам'яті**: Коли пам'ять, що використовується додатком, досягає певного
   порогу, система автоматично викликає GC.
2. **Ручний виклик**: Збирач сміття може бути викликаний вручну за допомогою методу **`GC.Collect()`**, однак робити це
   рекомендується вкрай рідко і лише в специфічних випадках. Це може призвести до непередбачуваних пауз у роботі
   додатка.
3. **Недостатність пам'яті**: Якщо під час створення нових об'єктів система визначає, що в купі недостатньо пам'яті,
   вона автоматично викликає GC.

### Фіналізація об'єктів і метод Dispose

- **Фіналізація**: Якщо об'єкт містить фіналізатор, GC викликає цей метод перед тим, як звільнити пам'ять, виділену для
  об'єкта. Це використовується для очищення некерованих ресурсів, таких як файлові дескриптори або підключення до баз
  даних.
- **Dispose()**: Для об'єктів, що використовують некеровані ресурси, краще реалізувати інтерфейс **IDisposable** і метод
  **Dispose()**. Метод `Dispose()` дозволяє вручну звільняти ресурси, а також забезпечує контроль за часом очищення, на
  відміну від фіналізаторів, які можуть працювати непередбачувано.

### Переваги та недоліки збирача сміття

#### **Переваги**:

- **Автоматичне керування пам'яттю**: Програмісту не потрібно вручну виділяти або звільняти пам'ять.
- **Зменшення витоків пам'яті**: Збирач сміття автоматично очищає невикористовувані об'єкти, зменшуючи ризик витоків
  пам'яті.

#### **Недоліки**:

- **Непередбачувані паузи**: Виклик GC може призвести до пауз у виконанні програми, особливо коли обробляються великі
  об'єкти або велика кількість об'єктів у Generation 2.
- **Очищення некерованих ресурсів**: Збирач сміття не може автоматично очищати некеровані ресурси, що вимагає додаткових
  дій зі сторони програміста.

### Оптимізація роботи збирача сміття

Щоб уникнути надмірного навантаження на збирача сміття, необхідно враховувати такі рекомендації:

1. **Ручне очищення ресурсів**: Використовуйте інтерфейс **IDisposable** і викликайте метод **Dispose()** для об'єктів,
   які містять некеровані ресурси, або використовуйте конструкцію **`using`** для автоматичного звільнення ресурсів.
2. **Уникнення великих об'єктів**: Великі об'єкти розміщуються в окремому сегменті пам'яті (Large Object Heap), який не
   підлягає компактному очищенню. Це може спричиняти фрагментацію
