# Інтерфейси та SOLID

Принципи SOLID допомагають створювати гнучкий та підтримуваний код. Інтерфейси відіграють ключову роль у реалізації цих принципів.

## S - Single Responsibility Principle (Принцип єдиної відповідальності)

Клас повинен мати лише одну причину для змін. Інтерфейси дозволяють розділити відповідальність на рівні контрактів.

## O - Open/Closed Principle (Принцип відкритості/закритості)

Програмні сутності повинні бути відкриті для розширення, але закриті для змін.
Використовуючи інтерфейси, ми можемо додавати нову поведінку, створюючи нові реалізації інтерфейсу, не змінюючи код, який цей інтерфейс використовує.

## L - Liskov Substitution Principle (Принцип підстановки Лісков)

Об'єкти в програмі повинні бути замінюваними на екземпляри їх підтипів без зміни правильності виконання програми.
Якщо клас реалізує інтерфейс, він повинен коректно виконувати контракт цього інтерфейсу.

## I - Interface Segregation Principle (Принцип розділення інтерфейсу)

Клієнти не повинні залежати від методів, які вони не використовують.
Краще створити багато вузькоспеціалізованих інтерфейсів, ніж один загальний.

```csharp
// Погано: один великий інтерфейс
interface IWorker
{
    void Work();
    void Eat();
}

// Добре: розділені інтерфейси
interface IWorkable
{
    void Work();
}

interface IFeedable
{
    void Eat();
}
```

## D - Dependency Inversion Principle (Принцип інверсії залежностей)

Модулі верхніх рівнів не повинні залежати від модулів нижніх рівнів. Обидва повинні залежати від абстракцій. Абстракції не повинні залежати від деталей. Деталі повинні залежати від абстракцій.

```csharp
// Залежність від абстракції (інтерфейсу), а не від конкретного класу
class Switch
{
    private IOSwitchable _device;

    public Switch(IOSwitchable device)
    {
        _device = device;
    }

    public void Operate()
    {
        _device.TurnOn();
    }
}

interface IOSwitchable
{
    void TurnOn();
}
```
