---
sidebar_position: 4
---

# Лямбда-вирази та анонімні методи

## Лямбда-вирази

**Лямбда-вираз** — це анонімна функція, яка використовується для створення делегатів або дерев виразів. Це компактний спосіб запису коду.

Синтаксис:

```
(параметри) => вираз_або_блок_коду
```

Оператор `=>` читається як "переходить у" (goes to).

### Приклади синтаксису

```csharp
// 1. Без параметрів
Action greet = () => Console.WriteLine("Hi");

// 2. Один параметр (дужки можна опустити)
Func<int, int> square = x => x * x;

// 3. Декілька параметрів
Func<int, int, int> add = (x, y) => x + y;

// 4. Блочна лямбда (якщо потрібно кілька інструкцій)
Func<int, int> factorial = n =>
{
    int result = 1;
    for (int i = 1; i <= n; i++)
        result *= i;
    return result;
};
```

## Анонімні методи

До появи лямбда-виразів (C# 3.0) використовувалися **анонімні методи** (C# 2.0). Зараз вони використовуються рідко, але їх можна зустріти в старому коді.

Синтаксис використовує ключове слово `delegate`:

```csharp
// Анонімний метод
Func<int, int, int> sumOld = delegate(int a, int b) {
    return a + b;
};

// Лямбда-аналог (сучасний підхід)
Func<int, int, int> sumNew = (a, b) => a + b;
```

Одна з відмінностей: анонімні методи дозволяють опускати параметри, якщо вони не використовуються, тоді як лямбда-вирази вимагають точного збігу сигнатури.

## Практичні приклади

### Фільтрація даних

Лямбда-вирази ідеально підходять для методів LINQ або методів списків, таких як `Where`, `Find`, `Select`.

```csharp
List<int> numbers = new List<int> { 1, 5, 8, 10, 15, 3 };

// Знайти всі числа менше 10
var smallNumbers = numbers.FindAll(n => n < 10);
// Результат: 1, 5, 8, 3

// Відфільтрувати парні числа
var evenNumbers = numbers.Where(n => n % 2 == 0);
// Результат: 8, 10
```

### Сортування

```csharp
List<string> names = new List<string> { "Ivan", "Anna", "Petro" };

// Сортування за довжиною імені
names.Sort((s1, s2) => s1.Length.CompareTo(s2.Length));
```

Лямбда-вирази роблять код значно коротшим і більш читабельним ("цукровий синтаксис"), позбавляючи необхідності створювати окремі методи для простих операцій.
