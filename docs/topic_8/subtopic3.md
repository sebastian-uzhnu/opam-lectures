# Класи пам’яті

## Класи пам’яті для масивів

Масиви в C# є посилальними типами даних, але розміщуються в пам'яті особливим чином.

### Стек і купа:

- **Стек**: Масиви не зберігаються в стеку, але змінні, що посилаються на масиви, можуть зберігатися в стеку. Стек
  використовується для зберігання локальних змінних, включаючи змінні, що є посиланнями на масиви.
- **Купа**: Самі масиви зберігаються в купі. Купа — це область пам’яті, в якій динамічно виділяються об'єкти. Коли масив
  створюється, пам'ять для нього виділяється в купі, і змінна, що посилається на масив, містить посилання на цю область
  пам'яті.

### Ініціалізація в пам'яті

- Масиви **примітивних типів** (наприклад, int, float) зберігаються в **послідовній області пам’яті** в купі. Це
  забезпечує швидкий доступ до елементів за індексом.
- Масиви **об'єктів** зберігаються в купі, і елементи масиву є **посиланнями на об'єкти** в купі.

### String як масив

У C# **string** фактично є **масивом символів (char)**, який зберігається в купі. На відміну від звичайних масивів,
рядки **незмінні (immutable)**. Це означає, що будь-яка операція, яка змінює рядок, створює новий масив символів у
пам'яті.

```csharp
string text = "Hello";
char firstChar = text[0]; // Доступ до елементу як до масиву
```

- Стек: Змінна `text` містить посилання на масив символів.
- Купа: Масив `{'H','e','l','l','o'}` зберігається в купі.

### Цікаві факти про масиви та пам’ять

1. **Контігусне розміщення:** Елементи масиву примітивних типів зберігаються у пам’яті **послідовно**, що покращує
   продуктивність через кеш процесора.
2. **Масиви і вирівнювання пам’яті:** Для швидкого доступу до даних компілятор може вирівнювати масиви у пам'яті за
   розміром слова процесора.
3. **Масиви двовимірні та багатовимірні:** В C# двовимірні масиви бувають **прямокутні (rectangular)** або **зубчасті (
   jagged)**. Зубчасті масиви — це масиви масивів, і кожен внутрішній масив може мати різну довжину.
4. **Масиви і GC (Garbage Collector):** Оскільки масиви розміщуються в купі, їхня пам’ять автоматично очищується GC,
   коли на них більше немає посилань.
5. **Ітератори та LINQ:** Масиви підтримують ітерації через foreach та LINQ, що дозволяє обробляти дані без явного
   доступу за індексом, але внутрішньо це все ще використовує прямий доступ до масиву у пам’яті.
6. **Пам’ять і оптимізація:** Масиви великих розмірів можуть впливати на фрагментацію пам’яті в купі. Знання цього
   дозволяє розробникам ефективніше управляти ресурсами та уникати частих алокацій і деалокацій.
7. **Масиви значень vs масиви посилань:** Масиви значень (наприклад, int[]) містять самі значення у пам’яті, а масиви
   посилань (наприклад, string[], object[]) містять лише **посилання на об’єкти**. Це впливає на швидкість доступу та
   використання пам’яті.

## Питання для самоперевірки:

1. Які способи ініціалізації масиву існують в C#?
2. Як масиви розміщуються в пам'яті C# (стек і купа)?
3. Як двовимірні масиви відрізняються від одномірних масивів в C#?
4. Які основні відмінності між стеком і купою в контексті зберігання масивів?
5. Як масиви об'єктів зберігаються в пам'яті в порівнянні з масивами примітивних типів?
6. Чим відрізняється string ві
