# Вказівники та багатомірні масиви

В C# вказівники використовуються в небезпечному коді (`unsafe`), де можна безпосередньо маніпулювати пам'яттю. Це також стосується багатомірних масивів, які можуть бути доступні через вказівники в контексті небезпечного коду.

## Навіщо потрібні вказівники?

Вказівники в C# надають можливість прямого доступу до пам'яті, що може бути корисним у специфічних сценаріях:

### Основні причини використання вказівників:

1. **Продуктивність**: Прямий доступ до пам'яті без перевірок може значно прискорити операції з великими обсягами даних
2. **Робота з неуправляємим кодом**: Інтеграція з бібліотеками на C/C++ або Windows API
3. **Низькорівневі операції**: Обробка зображень, аудіо, відео або інші операції, що вимагають побайтової маніпуляції
4. **Оптимізація критичних ділянок**: Код, що виконується дуже часто і потребує максимальної швидкості

### Як працюють вказівники з пам'яттю?

У звичайному C# коді збирач сміття (Garbage Collector) керує пам'яттю автоматично і може переміщувати об'єкти для оптимізації. Вказівники потребують фіксованої адреси в пам'яті, тому використовується ключове слово `fixed`, яке:

- Тимчасово "закріплює" об'єкт у пам'яті
- Забороняє GC переміщувати його під час роботи з вказівником
- Автоматично "відкріплює" об'єкт після завершення блоку `fixed`

## Коли варто використовувати вказівники?

### Рекомендовані сценарії:

**Обробка великих масивів даних:** обробка пікселів зображень у реальному часі, аудіо/відео кодування та декодування, наукові обчислення з матрицями великих розмірів.

**Виклик неуправляємих API:** робота з Win32 API, інтеграція з бібліотеками на C/C++, драйвери або системне програмування.

**Критична продуктивність:** ігрові движки (обробка геометрії, фізики), високочастотний трейдинг, системи реального часу.

**Спеціалізовані алгоритми:** криптографічні операції, компресія/декомпресія даних, парсинг бінарних протоколів.

### Коли НЕ варто використовувати вказівники:

**Звичайна бізнес-логіка:** робота з базами даних, веб-додатки (ASP.NET), CRUD операції.

**Невеликі обсяги даних:** масиви з кількома десятками елементів, стандартні колекції (List, Dictionary), рядки та прості об'єкти.

**Код, що потребує безпеки:** фінансові розрахунки, медичні системи, будь-який код де помилки можуть призвести до серйозних наслідків.

**Наявність безпечних альтернатив:** використовуйте `Span<T>` та `Memory<T>` для високопродуктивної роботи з пам'яттю, `Marshal` для роботи з неуправляємим кодом, `Array.Copy()` для копіювання масивів.

## Ризики використання вказівників

### Основні небезпеки:

**Порушення безпеки пам'яті:** можливість читання/запису за межами виділеної пам'яті, corruption пам'яті при неправильних обчисленнях адрес, складність відстеження таких помилок.

**Втрата переваг керованого коду:** збирач сміття не може ефективно працювати, втрата автоматичної перевірки меж масивів, відсутність автоматичного звільнення ресурсів.

**Складність підтримки:** код стає важчим для розуміння, ускладнюється тестування, вищий ризик помилок при рефакторингу.

**Обмеження платформи:** код з `unsafe` може не працювати на деяких платформах, потребує спеціальних дозволів у налаштуваннях проекту, може бути заблокований політиками безпеки.

### Вимоги для використання unsafe коду:

```xml
<!-- У файлі .csproj -->
<PropertyGroup>
  <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
</PropertyGroup>
```

## Сучасні альтернативи вказівникам

Починаючи з C# 7.2, з'явилися безпечніші альтернативи:

### `Span<T>` та `Memory<T>`

Ці типи надають високу продуктивність без використання `unsafe`:

```csharp
// Замість unsafe коду з вказівниками
Span<int> numbers = stackalloc int[100];
for (int i = 0; i < numbers.Length; i++)
{
    numbers[i] = i * 2; // Безпечний і швидкий доступ
}
```

### Переваги `Span<T>`:

- Безпека типів та меж масивів
- Висока продуктивність (майже як вказівники)
- Працює з масивами, стеком та неуправляємою пам'яттю
- Не потребує `unsafe` блоків

## Вказівники і двомірні масиви

### Ініціалізація і доступ через вказівники:

Ось приклад того, як можна використовувати вказівники для роботи з двомірними масивами.

```csharp
using System;

class Program
{
    unsafe static void Main()
    {
        int[,] matrix = new int[,]
        {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };

        fixed (int* p = matrix)  // Фіксація масиву в пам'яті
        {
            int* ptr = p;
            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    Console.Write(*(ptr + i * 4 + j) + " ");  // Доступ до елементів через вказівники
                }
                Console.WriteLine();
            }
        }
    }
}

```

**Примітки:**

- `fixed` фіксує масив в пам'яті, щоб не допустити його переміщення.
- `(ptr + i * 4 + j)` обчислює адрес елемента в двомірному масиві, де `i * 4` враховує кількість стовпчиків в рядку.

## Вказівники і трьохвимірні масиви

Для трьохвимірних масивів використання вказівників є складнішим. Тут також можна використовувати небезпечний код для доступу до елементів трьохвимірного масиву.

```csharp
using System;

class Program
{
    unsafe static void Main()
    {
        int[,,] cube = new int[,,]
        {
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 }
            },
            {
                { 10, 11, 12 },
                { 13, 14, 15 },
                { 16, 17, 18 }
            }
        };

        fixed (int* p = cube)  // Фіксація масиву в пам'яті
        {
            int* ptr = p;
            int depth = 2, rows = 3, columns = 3;
            for (int i = 0; i < depth; i++)
            {
                for (int j = 0; j < rows; j++)
                {
                    for (int k = 0; k < columns; k++)
                    {
                        Console.Write(*(ptr + i * rows * columns + j * columns + k) + " ");
                    }
                    Console.WriteLine();
                }
                Console.WriteLine();
            }
        }
    }
}

```

**Примітки:**

- `(ptr + i * rows * columns + j * columns + k)` обчислює адрес елемента в трьохвимірному масиві, де `i * rows * columns` враховує кількість рядків і стовпчиків на кожному рівні.

## Порівняння: Вказівники vs Безпечний код

### Приклад: Обробка масиву

**Безпечний спосіб (рекомендований для більшості випадків):**

```csharp
int[,] matrix = new int[1000, 1000];

// Стандартний доступ
for (int i = 0; i < 1000; i++)
{
    for (int j = 0; j < 1000; j++)
    {
        matrix[i, j] = i * j;
    }
}
```

**З використанням вказівників (для критичної продуктивності):**

```csharp
int[,] matrix = new int[1000, 1000];

unsafe
{
    fixed (int* ptr = matrix)
    {
        for (int i = 0; i < 1000; i++)
        {
            for (int j = 0; j < 1000; j++)
            {
                *(ptr + i * 1000 + j) = i * j;
            }
        }
    }
}
```

**Сучасний спосіб з `Span<T>` (найкращий компроміс):**

```csharp
int[,] matrix = new int[1000, 1000];
Span<int> span = MemoryMarshal.CreateSpan(ref matrix[0, 0], 1000 * 1000);

for (int i = 0; i < span.Length; i++)
{
    span[i] = (i / 1000) * (i % 1000);
}
```

### Різниця в продуктивності

Для масиву з 1,000,000 елементів (приблизні показники):

- **Безпечний доступ**: 100% (базова лінія)
- **Span\<T\>**: ~95% (майже однакова швидкість)
- **Вказівники**: ~90-95% (найшвидший, але складніший)

**Висновок**: У більшості випадків `Span<T>` надає достатню продуктивність без ризиків `unsafe` коду.

## Практичні рекомендації

### Правило прийняття рішення:

```
Потрібна висока продуктивність?
├─ НІ → Використовуйте звичайний безпечний код
└─ ТАК
   ├─ Чи є альтернатива (Span<T>, Memory<T>)?
   │  ├─ ТАК → Використовуйте Span<T> або Memory<T>
   │  └─ НІ
   │     ├─ Чи критична різниця в 5-10%?
   │     │  ├─ НІ → Використовуйте Span<T>
   │     │  └─ ТАК
   │     │     ├─ Чи маєте досвід з unsafe кодом?
   │     │     │  ├─ ТАК → Можна використовувати вказівники
   │     │     │  └─ НІ → Спочатку вивчіть альтернативи
```

### Чек-лист перед використанням вказівників:

- [ ] Я виміряв продуктивність і знайшов вузьке місце
- [ ] Безпечні альтернативи не підходять
- [ ] Я розумію ризики порушення безпеки пам'яті
- [ ] У мене є досвід роботи з вказівниками (або наставник)
- [ ] Код буде покритий тестами
- [ ] Проект дозволяє використання `unsafe` коду
- [ ] Я готовий підтримувати цей код у майбутньому

## Висновки

### Ключові моменти для запам'ятовування:

**Вказівники — це потужний інструмент, але не універсальне рішення.** Використовуйте тільки коли це дійсно необхідно. Завжди розглядайте безпечні альтернативи спочатку.

**Сучасний C# надає кращі альтернативи.** `Span<T>` та `Memory<T>` підходять для більшості випадків і забезпечують баланс між продуктивністю та безпекою.

**Вимірюйте продуктивність.** Не використовуйте вказівники "на всяк випадок". Профілюйте код перед оптимізацією.

**Безпека важливіша за швидкість.** У 95% випадків різниця в продуктивності не критична. Помилки з вказівниками можуть бути катастрофічними.

---

### Питання для самоперевірки:

1. Як фіксувати двомірний масив в пам'яті для використання з вказівниками в C#?
2. Яким чином можна отримати доступ до елементів двомірного масиву за допомогою вказівників?
3. Як обчислювати адреси елементів трьохвимірного масиву за допомогою вказівників?
4. Які основні проблеми та обмеження використання вказівників з багатомірними масивами в C#?
5. Які переваги та недоліки використання небезпечного коду для роботи з багатомірними масивами?
