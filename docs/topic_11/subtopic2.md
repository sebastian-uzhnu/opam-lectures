---
sidebar_position: 2
---

# 11.2 Абстрактні класи та інтерфейси

Часто базовий клас настільки загальний, що створювати його екземпляр не має сенсу. Наприклад, об'єкт "Тварина" є абстрактним поняттям, тоді як "Собака" чи "Кіт" — конкретним. Для таких випадків використовуються абстрактні класи та інтерфейси.

## Абстрактні класи

**Абстрактний клас** — це клас, об'єкт якого не можна створити. Він може містити як звичайні методи, так і абстрактні.

- Оголошується ключовим словом `abstract class`.
- **Абстрактний метод** (`abstract void Method();`) не має тіла реалізації в базовому класі.
- Похідний клас **зобов'язаний** реалізувати всі абстрактні методи (через `override`), якщо він сам не є абстрактним.

```csharp
public abstract class Animal
{
    public string Name { get; set; }

    // Звичайний метод (спільна логіка)
    public void Sleep()
    {
        Console.WriteLine("Zzz...");
    }

    // Абстрактний метод (реалізація залежить від конкретної тварини)
    public abstract void MakeSound();
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Гав-гав!");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Мяу!");
    }
}
```

## Інтерфейси

**Інтерфейс** — це контракт. Він визначає **що** повинен робити клас, але не **як**.

- Оголошується ключовим словом `interface`.
- Зазвичай імена інтерфейсів починаються з літери `I` (наприклад, `IMovable`, `IComparable`).
- Клас може реалізовувати (успадковувати) **багато** інтерфейсів, але тільки один базовий клас.
- Усі методи інтерфейсу за замовчуванням є `public` (до C# 8 не могли мати реалізації).

```csharp
// Інтерфейс для об'єктів, що можуть рухатися
public interface IMovable
{
    void Move(int speed);
}

// Інтерфейс для об'єктів, що мають інформацію
public interface IDisplayable
{
    void DisplayInfo();
}

// Клас Car реалізує ДВА інтерфейси
public class Car : IMovable, IDisplayable
{
    public string Model { get; set; }

    public void Move(int speed)
    {
        Console.WriteLine($"Авто слідує зі швидкістю {speed} км/год");
    }

    public void DisplayInfo()
    {
        Console.WriteLine($"Модель авто: {Model}");
    }
}
```

## Абстрактний клас чи Інтерфейс?

| Характеристика         | Абстрактний клас                                                    | Інтерфейс                                                         |
| :--------------------- | :------------------------------------------------------------------ | :---------------------------------------------------------------- |
| **Ключове слово**      | `abstract class`                                                    | `interface`                                                       |
| **Успадкування**       | Тільки один клас                                                    | Багато інтерфейсів                                                |
| **Реалізація методів** | Може мати методи з кодом                                            | До C# 8 - ні, зараз - Default Interface Methods                   |
| **Поля (змінні)**      | Може мати поля                                                      | Не може мати полів (тільки властивості)                           |
| **Конструктор**        | Може мати конструктор                                               | Не може мати конструктора                                         |
| **Призначення**        | "Is-a" (є чимось). Спільна функціональність для споріднених класів. | "Can-do" (може робити). Спільна поведінка для різнорідних класів. |

### Приклад вибору

- Якщо ми робимо гру про птахів: `Eagle`, `Penguin`, `Ostrich`.
  - Створимо абстрактний клас `Bird` (бо всі вони птахи, мають крила, дзьоб).
- Але пінгвін і страус не літають. А літак (`Airplane`) літає, хоч він і не птах.
  - Створимо інтерфейс `IFlyable` з методом `Fly()`.
  - `Eagle` : `Bird`, `IFlyable`
  - `Penguin` : `Bird`
  - `Airplane` : `Vehicle`, `IFlyable`

Це дозволяє досягти гнучкості та поліморфізму:

```csharp
List<IFlyable> flyingObjects = new List<IFlyable>();
flyingObjects.Add(new Eagle());
flyingObjects.Add(new Airplane());
// flyingObjects.Add(new Penguin()); // Помилка! Пінгвін не реалізує IFlyable

foreach (var obj in flyingObjects)
{
    obj.Fly(); // Спрацює для обох, хоча вони зовсім різні об'єкти
}
```
